/**
 * @file magic.h
 * @brief Provides methods to generate magic numbers for rook and bishop attacks.
 * @note Magic numbers are already precomputed, so this class is primarily used for generating new magic numbers if needed.
 */
#pragma once

#include <cstdint>
#include <memory>
#include <print>
#include <random>

#include "bitboard.h"
#include "slider_utils.h"

namespace chess_engine
{
/**
 * @brief The Magic class provides methods to generate magic numbers for rook and bishop attacks.
 *
 * Magic numbers are used in chess engines to efficiently compute attacks for rooks and bishops
 * by mapping occupancy bitboards to attack bitboards.
 */
class Magic
{
public:
    /**
     * @brief Initializes the magic numbers for bishops and rooks.
     *
     * This function initializes the precomputed magic numbers for bishops and rooks
     * for all squares.
     */
    static void initializeMagicNumbers()
    {
        for (Square square = Square::a8; square <= Square::h1; square++)
        {
            m_bishopMagicNumbersNotPrecomputed[static_cast<int>(square)] = generateMagicNumber(square, Bishop);
            m_rookMagicNumbersNotPrecomputed[static_cast<int>(square)] = generateMagicNumber(square, Rook);
        }
    }

private:
    /**
     * @brief Generates a random 64-bit unsigned integer.
     *
     * This function uses a random number generator to create a 64-bit unsigned integer.
     * It combines four random 16-bit numbers into a single 64-bit number.
     *
     * @return A randomly generated 64-bit unsigned integer.
     */
    static uint64_t generateRandomUint64()
    {
        std::random_device rd;
        std::mt19937_64 gen(rd());
        std::uniform_int_distribution<uint64_t> dist(0, UINT64_MAX);

        // Generate four random 16-bit numbers and combine them into a 64-bit number
        const uint64_t random1 = dist(gen) & 0xFFFF;
        const uint64_t random2 = dist(gen) & 0xFFFF;
        const uint64_t random3 = dist(gen) & 0xFFFF;
        const uint64_t random4 = dist(gen) & 0xFFFF;
        const uint64_t random64bit = (random1 << 48) | (random2 << 32) | (random3 << 16) | random4;

        return random64bit;
    }

    /**
     * @brief Generates a candidate magic number for rook or bishop attacks.
     *
     * This function generates a candidate magic number that could be used to efficiently compute
     * rook or bishop attacks. The candidate magic number is generated by combining
     * three random 64-bit unsigned integers to get a number with a low number of non-zero bits
     * (from chess programming wiki).
     *
     * @return A randomly generated candidate magic number.
     */
    static uint64_t generateCandidateMagicNumber()
    {
        return generateRandomUint64() & generateRandomUint64() & generateRandomUint64();
    }

    /**
     * @brief Generates a magic number for a given square and piece.
     *
     * This function generates a magic number that can be used to compute attacks for rooks or bishops
     * on the specified square. It uses a brute-force search to find a valid magic number that maps
     * all possible occupancy bitboards to their corresponding attack bitboards without collisions.
     *
     * @param square The square for which to generate the magic number.
     * @param piece The piece (Rook or Bishop) for which to generate the magic number.
     * @return A magic number for the specified square and piece.
     */
    static uint64_t generateMagicNumber(const Square square, const Piece piece)
    {
        // static_assert((piece == Piece::Rook || piece == Piece::Bishop),
        //               "Magic numbers can only be generated for Rooks and Bishops.");

        // Determine the number of relevant occupancy bits for the given square and piece
        const int relevantBits = piece == Bishop
                                         ? slider_utils::BISHOP_RELEVANT_BITS[static_cast<int>(square)]
                                         : slider_utils::ROOK_RELEVANT_BITS[static_cast<int>(square)];
        const int totalOccupancies = 1 << relevantBits;

        // Generate the attack mask for the square and piece
        const Bitboard attackMask = piece == Bishop
                                            ? slider_utils::generateBishopAttacks(square)
                                            : slider_utils::generateRookAttacks(square);

        // Allocate arrays for all possible occupancies, their attacks, and used attack sets
        auto occupancies = std::make_unique<Bitboard[]>(totalOccupancies);
        auto attacks = std::make_unique<Bitboard[]>(totalOccupancies);
        auto usedAttacks = std::make_unique<Bitboard[]>(totalOccupancies);

        // Generate all possible occupancies and their corresponding attack sets
        for (int index = 0; index < totalOccupancies; index++)
        {
            occupancies[index] = slider_utils::generateOccupancyMask(index, attackMask);
            attacks[index] = piece == Bishop
                                     ? slider_utils::generateBishopAttacksOnTheFly(square, occupancies[index])
                                     : slider_utils::generateRookAttacksOnTheFly(square, occupancies[index]);
        }

        // Brute-force search for a suitable magic number
        for (uint64_t i = 0; i < UINT64_MAX; i++)
        {
            const uint64_t magicNumber = generateCandidateMagicNumber();
            // Skip candidates with too few high bits set (heuristic for better magic numbers)
            if (Bitboard(attackMask.getBitboard() * magicNumber & 0xFF00000000000000ULL).getNumberOfBitsSet() < 6)
            {
                continue;
            }

            // Reset usedAttacks for this candidate
            std::fill_n(usedAttacks.get(), totalOccupancies, Bitboard(0));

            bool fail = false;
            // Test the candidate magic number for collisions
            for (int index = 0; index < totalOccupancies; index++)
            {
                const Bitboard occupancy = occupancies[index];
                const Bitboard attack = attacks[index];

                // Compute the magic index for this occupancy
                const int magicIndex = (occupancy.getBitboard() * magicNumber) >> (64 - relevantBits);

                // If this index is unused, store the attack set
                if (usedAttacks[magicIndex].getBitboard() == 0)
                {
                    usedAttacks[magicIndex] = attack;
                }
                // If a different attack set is already stored, this candidate fails
                else if (usedAttacks[magicIndex] != attack)
                {
                    fail = true;
                    break; // Magic number is not valid
                }
            }

            // If no collisions were found, return the valid magic number
            if (!fail)
            {
                // std::println("Found valid magic number: 0x{:016X}ULL", magicNumber);
                return magicNumber;
            }
        }

        // No valid magic number found
        return 0;
    }

public:
    // clang-format off
    /// Precomputed magic numbers for bishops
    static constexpr std::array<Bitboard, 64> m_bishopMagicNumbers =
    {
        0x01A0080100440044ULL,
        0x00A0052608A10800ULL,
        0x8184216202000100ULL,
        0x88220A0202002200ULL,
        0x33840420202E0020ULL,
        0x0386080524000100ULL,
        0x0406808809400000ULL,
        0x4082804048202808ULL,
        0x0044A014090A0C08ULL,
        0x000420040C2C4040ULL,
        0x0200108902082000ULL,
        0xA006024083001002ULL,
        0x1006445040070040ULL,
        0x8000120202620400ULL,
        0x20020A0101201000ULL,
        0x0940050402020200ULL,
        0x0140800810040080ULL,
        0x8044406084108211ULL,
        0x0004002048002041ULL,
        0x0224088804101000ULL,
        0x2403000090400200ULL,
        0x0032001241100128ULL,
        0x400C046201048202ULL,
        0x0020811044008841ULL,
        0x082020880802C400ULL,
        0x0001208004040400ULL,
        0x8404041242080010ULL,
        0x0841080001004100ULL,
        0x0001001001004009ULL,
        0x8408008000406008ULL,
        0xE068088020440440ULL,
        0x0012020204208244ULL,
        0x1058024201880800ULL,
        0x808C122200600480ULL,
        0x2001210120500400ULL,
        0x2004100821040400ULL,
        0x0240090100801040ULL,
        0x000210044002081AULL,
        0x18104484801B2400ULL,
        0x10180040800504A0ULL,
        0x0042080442104481ULL,
        0x8001042220100300ULL,
        0x8001092290000800ULL,
        0x0001002018003100ULL,
        0x020C110124002200ULL,
        0x4A04209002100900ULL,
        0x01110A020A404C01ULL,
        0x2490040482900020ULL,
        0x0204210168200000ULL,
        0x004C4202CC205090ULL,
        0x0A010420941000B0ULL,
        0x9100002C42020820ULL,
        0x0000019020220001ULL,
        0x1200444810190012ULL,
        0x0010510108008800ULL,
        0x0110040840802004ULL,
        0x0840120201044000ULL,
        0x02000022084A1820ULL,
        0x004000004202410AULL,
        0x0000200018C20884ULL,
        0x0400000022042400ULL,
        0x1450424010015240ULL,
        0x0020100408809C01ULL,
        0x0110049108122100ULL
    };

    /// Precomputed magic numbers for rooks
    static constexpr std::array<Bitboard, 64> m_rookMagicNumbers =
    {
        0x0880001040008021ULL,
        0x0340004220001000ULL,
        0x0200084080D32200ULL,
        0x208008000482D000ULL,
        0x1880080104008002ULL,
        0x0900140041000802ULL,
        0xC200012200008804ULL,
        0x46000C8020440201ULL,
        0x8410800080400022ULL,
        0x0208802000804012ULL,
        0x4002001200204080ULL,
        0x0140800800801000ULL,
        0x2075000800110104ULL,
        0x1002000200081004ULL,
        0x2104800100800200ULL,
        0x0003000041002882ULL,
        0x0900908000400020ULL,
        0x0400810020400100ULL,
        0x6200420020120080ULL,
        0x0442020010082040ULL,
        0x4439010008001005ULL,
        0x0404808004000200ULL,
        0x0200808002000100ULL,
        0x2000020000BC0041ULL,
        0x4100400080008020ULL,
        0x0800400080200085ULL,
        0x0000100080802000ULL,
        0x00A0401200200A01ULL,
        0x0405011100040801ULL,
        0x0030020080800400ULL,
        0x0240020400480110ULL,
        0x0113208E00040041ULL,
        0x4082004082002100ULL,
        0x0804201008400240ULL,
        0x5030040020A00800ULL,
        0x9008020A80801001ULL,
        0x3040080080800402ULL,
        0x800200244A000810ULL,
        0x4002100104000802ULL,
        0x8040040082000061ULL,
        0x2080008040008020ULL,
        0x0040008100430020ULL,
        0x4262002880420010ULL,
        0x005200C020920008ULL,
        0x8844008040080800ULL,
        0x9422104004080120ULL,
        0x1000040200010100ULL,
        0x0008209044020011ULL,
        0x1089003206408200ULL,
        0x2020004000300040ULL,
        0x0000812000100480ULL,
        0x0044201000090100ULL,
        0x0404800402080080ULL,
        0x1007020004008080ULL,
        0x5800220821100400ULL,
        0x4900008C00610200ULL,
        0x0000410010208001ULL,
        0x0303024000802015ULL,
        0x0002004008102082ULL,
        0x4010042009001001ULL,
        0x0096016010240822ULL,
        0x011A001004080102ULL,
        0x00A0810210084094ULL,
        0x5610210080442406ULL
    };
    // clang-format on

    /// Not precomputed magic numbers for bishops
    inline static std::array<Bitboard, 64> m_bishopMagicNumbersNotPrecomputed;
    /// Not precomputed magic numbers for rooks
    inline static std::array<Bitboard, 64> m_rookMagicNumbersNotPrecomputed;
};
} // namespace chess_engine