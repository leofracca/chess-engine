#pragma once

#include <cstdint>
#include <random>
#include <iostream>

#include "bitboard.h"
#include "pregenerated_moves.h"

#include <memory>

namespace chess_engine
{
class Magic
{
public:
    /**
     * @brief Generates a random 64-bit unsigned integer.
     *
     * This function uses a random number generator to create a 64-bit unsigned integer.
     * It combines four random 16-bit numbers into a single 64-bit number.
     *
     * @return A randomly generated 64-bit unsigned integer.
     */
    static constexpr uint64_t generateRandomUint64()
    {
        std::random_device rd;
        std::mt19937_64 gen(rd());
        std::uniform_int_distribution<uint64_t> dist(0, UINT64_MAX);

        // Generate four random 16-bit numbers and combine them into a 64-bit number
        const uint64_t random1 = dist(gen) & 0xFFFF;
        const uint64_t random2 = dist(gen) & 0xFFFF;
        const uint64_t random3 = dist(gen) & 0xFFFF;
        const uint64_t random4 = dist(gen) & 0xFFFF;
        const uint64_t random64bit = (random1 << 48) | (random2 << 32) | (random3 << 16) | random4;

        return random64bit;
    }

    /**
     * @brief Generates a candidate magic number for rook or bishop attacks.
     *
     * This function generates a candidate magic number that could be used to efficiently compute
     * rook or bishop attacks. The candidate magic number is generated by combining
     * three random 64-bit unsigned integers to get a number with a low number of non-zero bits
     * (from chess programming wiki).
     *
     * @return A randomly generated candidate magic number.
     */
    static constexpr uint64_t generateCandidateMagicNumber()
    {
        return generateRandomUint64() & generateRandomUint64() & generateRandomUint64();
    }

    static consteval uint64_t generateMagicNumber(const Square square, const Piece piece)
    {
        // TODO: Add comments before I forget how this works :)

        // static_assert((piece == Piece::Rook || piece == Piece::Bishop),
        //               "Magic numbers can only be generated for Rooks and Bishops.");

        const int relevantBits = piece == Piece::Bishop
            ? BISHOP_RELEVANT_BITS[static_cast<int>(square)]
            : ROOK_RELEVANT_BITS[static_cast<int>(square)];
        const int totalOccupancies = 1 << relevantBits;

        const Bitboard attackMask = piece == Piece::Bishop
            ? PregeneratedMoves::generateBishopAttacks(square)
            : PregeneratedMoves::generateRookAttacks(square);

        auto occupancies = std::make_unique<Bitboard[]>(totalOccupancies);
        auto attacks = std::make_unique<Bitboard[]>(totalOccupancies);
        auto usedAttacks = std::make_unique<Bitboard[]>(totalOccupancies);

        for (int index = 0; index < relevantBits; index++)
        {
            occupancies[index] = PregeneratedMoves::generateOccupancyMask(index, attackMask);
            attacks[index] = piece == Piece::Bishop
                ? PregeneratedMoves::generateBishopAttacksOnTheFly(square, occupancies[index])
                : PregeneratedMoves::generateRookAttacksOnTheFly(square, occupancies[index]);
        }

        for (int i = 0; i < UINT64_MAX; i++)
        {
            const uint64_t magicNumber = generateCandidateMagicNumber();
            if ((Bitboard(attackMask.getBitboard() * magicNumber).getNumberOfBitsSet() & 0xFF00000000000000ULL) < 6)
            {
                continue;
            }

            std::fill_n(usedAttacks.get(), totalOccupancies, Bitboard(0));

            bool fail = false;
            for (int index = 0; index < totalOccupancies; index++)
            {
                const Bitboard occupancy = occupancies[index];
                const Bitboard attack = attacks[index];

                const int magicIndex = (occupancy.getBitboard() * magicNumber) >> (64 - relevantBits);
                if (usedAttacks[magicIndex].getBitboard() == 0)
                {
                    usedAttacks[magicIndex] = attack;
                }
                else if (usedAttacks[magicIndex] != attack)
                {
                    fail = true;
                    break; // Magic number is not valid
                }
            }

            if (!fail)
            {
                // If we reach here, we found a valid magic number
                return magicNumber;
            }
        }

        return 0; // If we reach here, no valid magic number was found
    }

private:
    // clang-format off
    static constexpr std::array<int, 64> BISHOP_RELEVANT_BITS = //< Number of relevant bits for bishop attacks for each square
    {
        6, 5, 5, 5, 5, 5, 5, 6,
        5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 7, 7, 7, 7, 5, 5,
        5, 5, 7, 9, 9, 7, 5, 5,
        5, 5, 7, 9, 9, 7, 5, 5,
        5, 5, 7, 7, 7, 7, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5,
        6, 5, 5, 5, 5, 5, 5, 6
    };
    static constexpr std::array<int, 64> ROOK_RELEVANT_BITS = //< Number of relevant bits for rook attacks for each square
    {
        12, 11, 11, 11, 11, 11, 11, 12,
        11, 10, 10, 10, 10, 10, 10, 11,
        11, 10, 10, 10, 10, 10, 10, 11,
        11, 10, 10, 10, 10, 10, 10, 11,
        11, 10, 10, 10, 10, 10, 10, 11,
        11, 10, 10, 10, 10, 10, 10, 11,
        11, 10, 10, 10, 10, 10, 10, 11,
        12, 11, 11, 11, 11, 11, 11, 12
    };
    // clang-format on
};
} // namespace chess_engine